=================================================================================
                  FIX 3 - BUFFER HEALTH CHECK
                     âœ¨ OPTIONAL ENHANCEMENT âœ¨
=================================================================================

WHY THIS FIX IS NEEDED:
Aggressive recovery seeks backward 3 seconds to force buffer refresh. If the
buffer only has 2 seconds of video data, seeking back 3 seconds exhausts it
completely - guaranteeing the recovery will fail. This wastes a recovery attempt
and potentially makes the situation worse.

WHAT THIS FIX DOES:
Before attempting aggressive recovery, check total buffer length. If buffer < 5
seconds, log a warning and skip the recovery attempt entirely. This allows the
buffer to naturally grow before attempting recovery, preventing catastrophic
buffer exhaustion.

WHY 5 SECONDS:
- Backward seek distance: 3 seconds
- Safety margin: 2 seconds remaining buffer
- Total: 5 seconds ensures the seek won't exhaust the buffer

IMPACT: Improves overall recovery efficiency by preventing doomed attempts.
Optional because Fixes 1+2 may be sufficient, but this adds extra protection.

---
artifact: task
name: Fix 3 - Add Buffer Health Check Before Recovery
description: Detailed implementation guide to prevent recovery attempts when buffer is too low, avoiding wasted recovery cycles
issue_id: Fix 3
priority: LOW (Optional Enhancement)
file: Code.js
version: 1.21 â†’ 1.22
estimated_time: 5 minutes
parent_task: Fix Summary.md
depends_on: Fix 2 (recommended but optional)
---

# Task: Fix 3 - Add Buffer Health Check Before Recovery

**Issue ID:** Fix 3  
**Priority:** LOW (Optional Enhancement)  
**File:** `Code.js`  
**Version:** 1.21 â†’ 1.22  
**Estimated Time:** 5 minutes  
**Depends On:** Fix 2 (recommended but not required)

---

## ðŸŽ¯ Objective

Add a buffer health check before attempting aggressive recovery to avoid wasted recovery attempts when buffer is too low. If buffer < 5 seconds, skip recovery and let buffer naturally grow.

**Problem:** Currently, aggressive recovery can be attempted even when buffer is very small (e.g., 1-2 seconds). Seeking backward 3 seconds with only 2 seconds of buffer exhausts the buffer completely, guaranteeing failure.

**Solution:** 
1. Before aggressive recovery, check total buffer length
2. If buffer < 5 seconds, log warning and skip recovery
3. Let buffer naturally grow before attempting recovery

---

## ðŸ“‹ Pre-Implementation Checklist

- [ ] Fix 1 has been completed (debounce handler added)
- [ ] Fix 2 has been completed (recommended for best results)
- [ ] Current `Code.js` is version 1.21 (or 1.20 if skipping Fix 2)
- [ ] Backup created: `Code_v1.21_backup.js`
- [ ] Ready to test in browser after changes

---

## ðŸ”§ Implementation Steps

### Step 0: Verify Code Structure (CRITICAL - Do This First!)

**Open Code.js and verify these exact lines exist:**

**Line 2-3 Check:**
```javascript
// @name          Mega Ad Dodger 3000 (Stealth Reactor Core) 1.21
// @version       1.21
```
- [ ] Line 2 shows version 1.21 (or 1.20 if Fix 2 not done)
- [ ] Line 3 shows version 1.21 (or 1.20 if Fix 2 not done)

**Line 958-972 Check (where code will be inserted):**
```javascript
                    if (buffered.length > 0) {
                        const bufferEnd = buffered.end(buffered.length - 1);
                        const seekTarget = bufferEnd - 0.5;
                        const timeDiff = Math.abs(currentTime - seekTarget);
                        const isStuckAtBufferEnd = Math.abs(currentTime - bufferEnd) < 0.5;

                        // CRITICAL: If stuck at buffer end, player can't advance because next segment is blocked
                        // This requires aggressive recovery to force stream refresh
                        if (isStuckAtBufferEnd) {
                            Logger.add('Stuck at buffer end detected - requires aggressive recovery', {
                                currentTime,
                                bufferEnd,
                                diff: Math.abs(currentTime - bufferEnd)
                            });
                            needsAggressiveRecovery = true;
```
- [ ] Line 958 has `if (buffered.length > 0) {`
- [ ] Lines959-962 calculate bufferEnd, seekTarget, timeDiff, isStuckAtBufferEnd
- [ ] Line 966 has `if (isStuckAtBufferEnd) {`
- [ ] Line 972 has `needsAggressiveRecovery = true;`

**âš ï¸ IF ANY OF THE ABOVE DON'T MATCH:**
- STOP - Do not proceed
- Code may have been modified
- Report mismatch and ask for guidance

---

### Step 1: Create Backup

**Action:** Copy current Code.js to backup file

```powershell
# Run in project directory
Copy-Item "Code.js" "Code_v1.21_backup.js"
```

**Validation:**
- [ ] `Code_v1.21_backup.js` exists
- [ ] Backup file has same size as `Code.js`

---

### Step 2: Update Version Number

**File:** `Code.js`  
**Lines:** 2-3

**Update line 2:**
```javascript
// @name          Mega Ad Dodger 3000 (Stealth Reactor Core) 1.22
```

**Update line 3:**
```javascript
// @version       1.22
```

**Validation:**
- [ ] Line 2 shows version 1.22
- [ ] Line 3 shows version 1.22
- [ ] Both lines match

---

### Step 3: Add Buffer Health Check

**File:** `Code.js`  
**Location:** After line 962 (after isStuckAtBufferEnd calculation)  
**Context:** Inside Resilience module, before aggressive recovery decision

**ðŸ” Find this code block (lines 958-966):**
```javascript
                    if (buffered.length > 0) {
                        const bufferEnd = buffered.end(buffered.length - 1);
                        const seekTarget = bufferEnd - 0.5;
                        const timeDiff = Math.abs(currentTime - seekTarget);
                        const isStuckAtBufferEnd = Math.abs(currentTime - bufferEnd) < 0.5;

                        // CRITICAL: If stuck at buffer end, player can't advance because next segment is blocked
                        // This requires aggressive recovery to force stream refresh
                        if (isStuckAtBufferEnd) {
```

**âœï¸ INSERT AFTER line 962 (after isStuckAtBufferEnd calculation, BEFORE the comment):**

Add this new code block:
```javascript

                        // Check buffer health before attempting aggressive recovery
                        const bufferStart = buffered.start(0);
                        const bufferLength = bufferEnd - bufferStart;

                        if (isStuckAtBufferEnd && bufferLength < 5) {
                            Logger.add('Insufficient buffer for recovery - waiting for buffer to grow', {
                                bufferLength: bufferLength.toFixed(2),
                                bufferStart: bufferStart.toFixed(2),
                                bufferEnd: bufferEnd.toFixed(2),
                                currentTime: currentTime.toFixed(2)
                            });
                            isFixing = false;
                            return; // Don't attempt recovery with low buffer
                        }
```

**ðŸ“ Result should look like (lines 958-978):**
```javascript
                    if (buffered.length > 0) {
                        const bufferEnd = buffered.end(buffered.length - 1);
                        const seekTarget = bufferEnd - 0.5;
                        const timeDiff = Math.abs(currentTime - seekTarget);
                        const isStuckAtBufferEnd = Math.abs(currentTime - bufferEnd) < 0.5;

                        // Check buffer health before attempting aggressive recovery
                        const bufferStart = buffered.start(0);
                        const bufferLength = bufferEnd - bufferStart;

                        if (isStuckAtBufferEnd && bufferLength < 5) {
                            Logger.add('Insufficient buffer for recovery - waiting for buffer to grow', {
                                bufferLength: bufferLength.toFixed(2),
                                bufferStart: bufferStart.toFixed(2),
                                bufferEnd: bufferEnd.toFixed(2),
                                currentTime: currentTime.toFixed(2)
                            });
                            isFixing = false;
                            return; // Don't attempt recovery with low buffer
                        }

                        // CRITICAL: If stuck at buffer end, player can't advance because next segment is blocked
                        // This requires aggressive recovery to force stream refresh
                        if (isStuckAtBufferEnd) {
```

**ðŸ“ What Changed:**
1. **Added buffer calculation** (lines 965-967): Calculate bufferStart and bufferLength
2. **Added health check** (lines 969-979): Check if buffer < 5 seconds BEFORE attempting recovery
3. **Early return** (line 978): Skip recovery if buffer too low, reset fixing lock

**Validation:**
- [ ] New code inserted after `isStuckAtBufferEnd` calculation
- [ ] New code inserted BEFORE the "CRITICAL:" comment
- [ ] ALL new lines use 24 spaces for base indentation (6 levels)
- [ ] Early return includes `isFixing = false;` to reset lock
- [ ] Buffer threshold is exactly `< 5` (not <= or other value)

---

### Step 4: Post-Implementation Verification

**Action:** Verify all changes were applied correctly

**Quick Syntax Check:**
1. Save Code.js
2. Look for any red/error highlighting in editor
3. Search for "Insufficient buffer for recovery" using Ctrl+F

**Expected Results:**
- [ ] Search finds exactly 1 occurrence (the new log message)
- [ ] Version shows 1.22 (lines 2 and 3)
- [ ] New buffer health check exists between lines 963-979
- [ ] No syntax errors or red highlights in editor
- [ ] File saved successfully

**Visual Verification - Count the Changes:**
- [ ] 3 new variable declarations: `bufferStart`, `bufferLength` (calculated from existing `bufferEnd`)
- [ ] 1 new if block checking `bufferLength < 5`
- [ ] 1 new Logger.add for insufficient buffer
- [ ] 1 early return with `isFixing = false`

**âš ï¸ If verification fails:**
- Restore from backup: `Copy-Item "Code_v1.21_backup.js" "Code.js" -Force`
- Review Step 3 carefully
- Ensure code inserted in correct location (AFTER isStuckAtBufferEnd, BEFORE comment)

---

## ðŸ§ª Testing Procedure

### Pre-Test Validation
- [ ] Code.js saved with all changes
- [ ] No syntax errors (check editor highlighting)
- [ ] Version shows 1.22
- [ ] Buffer health check code visible in file

### Browser Testing

#### Test 1: Script Loads Successfully
1. Open Tampermonkey dashboard
2. Update Code.js script
3. Save and navigate to Twitch.tv stream

**Expected Result:**
- [ ] No console errors on page load
- [ ] Script initializes successfully
- [ ] See "Core initialized" in logs

#### Test 2: Low Buffer Detection
1. Watch stream and wait for potential ad detection
2. Look for buffer health check logs
3. Check if recovery is skipped when buffer low

**Expected Logs (Low Buffer Case):**
```
[timestamp] Stuck at buffer end detected - requires aggressive recovery | {...}
[timestamp] Insufficient buffer for recovery - waiting for buffer to grow | {"bufferLength":"2.34","bufferStart":"X.XX","bufferEnd":"Y.YY","currentTime":"Z.ZZ"}
```

**Validation:**
- [ ] "Insufficient buffer" message appears when buffer < 5s
- [ ] Recovery is skipped (no "Executing aggressive recovery" message after)
- [ ] `isFixing` lock is released (subsequent checks can proceed)

#### Test 3: Sufficient Buffer Allows Recovery
1. Continue watching stream
2. Wait for buffer to grow > 5 seconds
3. Verify recovery proceeds normally

**Expected Logs (Sufficient Buffer Case):**
```
[timestamp] Stuck at buffer end detected - requires aggressive recovery | {...}
[timestamp] Executing aggressive recovery: forcing stream refresh | {...}
```

**Validation:**
- [ ] NO "Insufficient buffer" message when buffer > 5s
- [ ] Recovery proceeds as normal
- [ ] Buffer health check doesn't block legitimate recoveries

#### Test 4: Compare Metrics
1. Export logs: `exportTwitchAdLogs()`
2. Compare with previous versions

**Expected Improvements:**
- [ ] Fewer failed recovery attempts
- [ ] "Insufficient buffer" warnings instead of failed recoveries
- [ ] Overall lower `aggressive_recoveries` metric
- [ ] No increase in stuck streams (health check doesn't prevent necessary recoveries)

---

## ðŸ“Š Success Criteria

### Must Have (Critical)
- [x] Buffer health check added before aggressive recovery
- [x] Recovery skipped when buffer < 5 seconds
- [x] isFixing lock properly released on early return
- [x] Script loads without errors
- [x] Legitimate recoveries still proceed when buffer sufficient

### Nice to Have
- [ ] Logs show buffer health checks working
- [ ] Fewer wasted recovery attempts
- [ ] Metrics show improved efficiency

---

## ðŸš¨ Rollback Plan

If implementation fails or causes issues:

### Quick Rollback
```powershell
# Restore backup
Copy-Item "Code_v1.21_backup.js" "Code.js" -Force
```

### Validation After Rollback
- [ ] Version shows 1.21 again (or 1.20)
- [ ] Original behavior restored
- [ ] Can proceed with debugging

---

## âš ï¸ Common Pitfalls & Troubleshooting

### Pitfall 1: Wrong Insertion Location
**Symptom:** Code doesn't compile or logic flow broken  
**Cause:** Inserted code in wrong place (before or after wrong line)  
**Fix:** Ensure code inserted AFTER `isStuckAtBufferEnd` calculation, BEFORE "CRITICAL:" comment

### Pitfall 2: Forgot `isFixing = false` 
**Symptom:** Recovery never attempts again after low buffer  
**Cause:** Lock not released on early return  
**Fix:** Ensure `isFixing = false;` line is included before `return;`

### Pitfall 3: Wrong Buffer Threshold
**Symptom:** Too many "insufficient buffer" messages or too few  
**Cause:** Used wrong number (< 2 or < 10 instead of < 5)  
**Fix:** Confirm threshold is exactly `< 5` (5 seconds)

### Pitfall 4: Recovery Never Fires
**Symptom:** Stream stuck, no recovery attempts at all  
**Cause:** Buffer threshold too high or condition too strict  
**Fix:** Check logs to see if buffer is consistently < 5s, may need to lower threshold

---

## ðŸ“ Implementation Notes

### Why 5 Seconds Buffer Minimum?
- Backward seek distance: 3 seconds
- Safety margin: 2 seconds minimum remaining buffer
- **Total:** 5 seconds ensures seeking backward doesn't exhaust buffer

### Why Check Before Aggressive Recovery Only?
- Normal recovery (small seeks) doesn't exhaust buffer
- Aggressive recovery seeks backward 3 seconds, requiring  sufficient buffer
- This prevents catastrophic buffer exhaustion

### Buffer Start vs Buffer End
- `bufferStart`: Earliest video time available in buffer
- `bufferEnd`: Latest video time available in buffer
- `bufferLength`: Total amount of video buffered (end - start)
- Only checking length at current position isn't enough - need total buffer

---

## âœ… Final Checklist

Before marking as complete:

- [ ] All code changes implemented correctly
- [ ] Version updated to 1.22 (lines 2 AND 3)
- [ ] Backup created and verified
- [ ] Script loads without errors in Tampermonkey
- [ ] Buffer health check code inserted correctly
- [ ] `isFixing = false;` included in early return
- [ ] Buffer threshold is `< 5`
- [ ] Low buffer cases logged correctly
- [ ] Sufficient buffer cases still allow recovery
- [ ] Overall recovery efficiency improved

---

## ðŸ”„ Next Steps

After successful implementation of Fix 3:

1. **Monitor Performance:** Watch stream for 30+ minutes, collect logs with `exportTwitchAdLogs()`
2. **Check Logs:** Look for "Insufficient buffer" messages - should appear occasionally but not too often
3. **Validate Metrics:** Compare `aggressive_recoveries` count - should be lower with fewer failures
4. **Document Results:** Note improvement in recovery efficiency

**If All 3 Fixes Complete:**
- Compare v1.19 (original) vs v1.22 (all fixes) metrics
- Document success rate improvement
- Monitor long-term stability (1+ hour streams)

**Success Indicators:**
- âœ… Max 1 recovery per 10 seconds (Fix 1 working)
- âœ… Higher recovery success rate (Fix 2 working)
- âœ… Fewer wasted recovery attempts (Fix 3 working)
- âœ… No stream collapses over extended periods
