const fs = require('fs');
const path = require('path');
const vm = require('vm');
const { generateManifest } = require('./generate-manifest');

const ROOT = path.join(__dirname, '..');
const MANIFEST_PATH = path.join(__dirname, 'manifest.json');
const DOC_PATH = path.join(ROOT, 'docs', 'ARCHITECTURE.md');
const CONFIG_DOC_PATH = path.join(ROOT, 'docs', 'CONFIG.md');
const LOG_TAGS_DOC_PATH = path.join(ROOT, 'docs', 'LOG_TAGS.md');
const CONFIG_SRC_PATH = path.join(ROOT, 'src', 'config', 'Config.js');
const LOG_TAGS_SRC_PATH = path.join(ROOT, 'src', 'monitoring', 'LogTags.js');
const START = '<!-- LOAD_ORDER_START -->';
const END = '<!-- LOAD_ORDER_END -->';

const detectNewline = (text) => (text.includes('\r\n') ? '\r\n' : '\n');

const loadExport = (filePath, exportName) => {
    const code = fs.readFileSync(filePath, 'utf8');
    const sandbox = { console };
    vm.createContext(sandbox);
    vm.runInContext(
        `${code}\nthis.__EXPORT__ = (typeof ${exportName} !== 'undefined') ? ${exportName} : undefined;`,
        sandbox,
        { filename: filePath }
    );
    if (!sandbox.__EXPORT__) {
        throw new Error(`[sync-docs] Failed to load ${exportName} from ${filePath}`);
    }
    return sandbox.__EXPORT__;
};

const formatValue = (value) => {
    if (typeof value === 'string') return value;
    if (value === null || value === undefined) return String(value);
    return JSON.stringify(value);
};

const renderTable = (rows, newline) => {
    const lines = [
        '| Key | Default |',
        '| --- | --- |',
        ...rows.map(([key, value]) => `| ${key} | \`${formatValue(value)}\` |`)
    ];
    return lines.join(newline);
};

const renderConfigDoc = (config, newline) => {
    const generalRows = [];
    const sections = [];

    Object.entries(config).forEach(([key, value]) => {
        if (value && typeof value === 'object' && !Array.isArray(value)) {
            sections.push({ title: key, rows: Object.entries(value) });
        } else {
            generalRows.push([key, value]);
        }
    });

    const lines = [
        '# Config Reference',
        '',
        'Generated by build/sync-docs.js. Do not edit by hand.',
        ''
    ];

    if (generalRows.length) {
        lines.push('## General', renderTable(generalRows, newline), '');
    }

    sections.forEach(section => {
        lines.push(`## ${section.title}`, renderTable(section.rows, newline), '');
    });

    return lines.join(newline).trimEnd() + newline;
};

const renderLogTagsDoc = (logTags, logTagRegistry, newline) => {
    const tags = logTags && logTags.TAG ? Object.values(logTags.TAG) : [];
    const registryGroups = Array.isArray(logTagRegistry?.GROUPS) ? logTagRegistry.GROUPS : [];
    const groupByTag = (tag) => {
        const raw = tag.replace(/^\[|\]$/g, '');
        const normalized = logTagRegistry?.normalizeTag
            ? logTagRegistry.normalizeTag(raw)
            : { tagKey: raw };
        const group = logTagRegistry?.getGroupForTag
            ? logTagRegistry.getGroupForTag(normalized.tagKey)
            : null;
        return group?.id || 'other';
    };
    const schemaForTag = (tag) => {
        const raw = tag.replace(/^\[|\]$/g, '');
        if (!logTagRegistry?.getSchema) return null;
        return logTagRegistry.getSchema(raw);
    };

    const lines = [
        '# Log Tags',
        '',
        'Generated by build/sync-docs.js. Do not edit by hand.',
        ''
    ];

    lines.push('## Groups');
    lines.push('| Group | Legend |');
    lines.push('| --- | --- |');
    registryGroups.forEach(group => {
        lines.push(`| ${group.id} | ${group.legend} |`);
    });
    lines.push('');

    lines.push('## Tags');
    lines.push('| Tag | Group | Schema |');
    lines.push('| --- | --- | --- |');
    tags.forEach(tag => {
        const group = groupByTag(tag);
        const schema = schemaForTag(tag);
        const schemaText = schema ? schema.join(', ') : '';
        lines.push(`| ${tag} | ${group} | ${schemaText} |`);
    });
    lines.push('');

    return lines.join(newline).trimEnd() + newline;
};

const syncDoc = (docPath, content, label, isCheck) => {
    const exists = fs.existsSync(docPath);
    const existing = exists ? fs.readFileSync(docPath, 'utf8') : '';
    const newline = detectNewline(existing || content);
    const normalized = content.replace(/\n/g, newline);

    if (isCheck) {
        if (!exists || existing !== normalized) {
            console.error(`[sync-docs] ${label} is out of sync`);
            return false;
        }
        return true;
    }

    if (!exists || existing !== normalized) {
        fs.writeFileSync(docPath, normalized);
        console.log(`[sync-docs] Updated ${label}`);
    }
    return true;
};

const isCheck = process.argv.includes('--check');
let ok = true;

const docBuffer = fs.readFileSync(DOC_PATH);
const docText = docBuffer.toString('utf8');
const newline = detectNewline(docText);
const manifestResult = generateManifest({ check: isCheck });
if (isCheck && !manifestResult.ok) {
    console.error('[sync-docs] build/manifest.json is out of sync');
    ok = false;
}
const manifest = manifestResult.manifest || JSON.parse(fs.readFileSync(MANIFEST_PATH, 'utf8'));
const ordered = [
    ...(Array.isArray(manifest.priority) ? manifest.priority : []),
    manifest.entry || 'core/orchestrators/CoreOrchestrator.js'
];
const list = ordered
    .map((file, index) => `${index + 1}. \`${file}\``)
    .join(newline);

const expectedBlock = `${START}${newline}${list}${newline}${END}`;
const startBuffer = Buffer.from(START, 'ascii');
const endBuffer = Buffer.from(END, 'ascii');
const startIndex = docBuffer.indexOf(startBuffer);
const endIndex = docBuffer.indexOf(endBuffer);

if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
    console.error('[sync-docs] Load order markers not found in docs/ARCHITECTURE.md');
    process.exit(1);
}

const updatedBuffer = Buffer.concat([
    docBuffer.slice(0, startIndex),
    Buffer.from(expectedBlock, 'ascii'),
    docBuffer.slice(endIndex + endBuffer.length)
]);

if (isCheck) {
    if (!docBuffer.equals(updatedBuffer)) {
        console.error('[sync-docs] docs/ARCHITECTURE.md is out of sync with build/manifest.json');
        ok = false;
    }
} else if (!docBuffer.equals(updatedBuffer)) {
    fs.writeFileSync(DOC_PATH, updatedBuffer);
    console.log('[sync-docs] Updated docs/ARCHITECTURE.md module load order');
}

try {
    const config = loadExport(CONFIG_SRC_PATH, 'CONFIG');
    const logTags = loadExport(LOG_TAGS_SRC_PATH, 'LogTags');
    const logTagRegistry = loadExport(
        path.join(ROOT, 'src', 'monitoring', 'LogTagRegistry.js'),
        'LogTagRegistry'
    );
    const configDoc = renderConfigDoc(config, '\n');
    const logTagsDoc = renderLogTagsDoc(logTags, logTagRegistry, '\n');
    ok = syncDoc(CONFIG_DOC_PATH, configDoc, 'docs/CONFIG.md', isCheck) && ok;
    ok = syncDoc(LOG_TAGS_DOC_PATH, logTagsDoc, 'docs/LOG_TAGS.md', isCheck) && ok;
} catch (err) {
    console.error(err.message || err);
    ok = false;
}

if (isCheck && !ok) {
    process.exit(1);
}
