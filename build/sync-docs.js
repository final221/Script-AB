const fs = require('fs');
const path = require('path');
const vm = require('vm');

const ROOT = path.join(__dirname, '..');
const MANIFEST_PATH = path.join(__dirname, 'manifest.json');
const DOC_PATH = path.join(ROOT, 'docs', 'ARCHITECTURE.md');
const CONFIG_DOC_PATH = path.join(ROOT, 'docs', 'CONFIG.md');
const LOG_TAGS_DOC_PATH = path.join(ROOT, 'docs', 'LOG_TAGS.md');
const CONFIG_SRC_PATH = path.join(ROOT, 'src', 'config', 'Config.js');
const LOG_TAGS_SRC_PATH = path.join(ROOT, 'src', 'monitoring', 'LogTags.js');
const START = '<!-- LOAD_ORDER_START -->';
const END = '<!-- LOAD_ORDER_END -->';

const detectNewline = (text) => (text.includes('\r\n') ? '\r\n' : '\n');

const loadExport = (filePath, exportName) => {
    const code = fs.readFileSync(filePath, 'utf8');
    const sandbox = { console };
    vm.createContext(sandbox);
    vm.runInContext(
        `${code}\nthis.__EXPORT__ = (typeof ${exportName} !== 'undefined') ? ${exportName} : undefined;`,
        sandbox,
        { filename: filePath }
    );
    if (!sandbox.__EXPORT__) {
        throw new Error(`[sync-docs] Failed to load ${exportName} from ${filePath}`);
    }
    return sandbox.__EXPORT__;
};

const formatValue = (value) => {
    if (typeof value === 'string') return value;
    if (value === null || value === undefined) return String(value);
    return JSON.stringify(value);
};

const renderTable = (rows, newline) => {
    const lines = [
        '| Key | Default |',
        '| --- | --- |',
        ...rows.map(([key, value]) => `| ${key} | \`${formatValue(value)}\` |`)
    ];
    return lines.join(newline);
};

const renderConfigDoc = (config, newline) => {
    const generalRows = [];
    const sections = [];

    Object.entries(config).forEach(([key, value]) => {
        if (value && typeof value === 'object' && !Array.isArray(value)) {
            sections.push({ title: key, rows: Object.entries(value) });
        } else {
            generalRows.push([key, value]);
        }
    });

    const lines = [
        '# Config Reference',
        '',
        'Generated by build/sync-docs.js. Do not edit by hand.',
        ''
    ];

    if (generalRows.length) {
        lines.push('## General', renderTable(generalRows, newline), '');
    }

    sections.forEach(section => {
        lines.push(`## ${section.title}`, renderTable(section.rows, newline), '');
    });

    return lines.join(newline).trimEnd() + newline;
};

const renderLogTagsDoc = (logTags, newline) => {
    const tags = logTags && logTags.TAG ? Object.values(logTags.TAG) : [];
    const groups = new Map();

    tags.forEach(tag => {
        const match = /^\[([A-Z_]+):/.exec(tag);
        const group = match ? match[1] : 'OTHER';
        if (!groups.has(group)) {
            groups.set(group, []);
        }
        groups.get(group).push(tag);
    });

    const lines = [
        '# Log Tags',
        '',
        'Generated by build/sync-docs.js. Do not edit by hand.',
        ''
    ];

    Array.from(groups.entries()).forEach(([group, groupTags]) => {
        lines.push(`## ${group}`);
        groupTags.forEach(tag => lines.push(`- ${tag}`));
        lines.push('');
    });

    return lines.join(newline).trimEnd() + newline;
};

const syncDoc = (docPath, content, label, isCheck) => {
    const exists = fs.existsSync(docPath);
    const existing = exists ? fs.readFileSync(docPath, 'utf8') : '';
    const newline = detectNewline(existing || content);
    const normalized = content.replace(/\n/g, newline);

    if (isCheck) {
        if (!exists || existing !== normalized) {
            console.error(`[sync-docs] ${label} is out of sync`);
            return false;
        }
        return true;
    }

    if (!exists || existing !== normalized) {
        fs.writeFileSync(docPath, normalized);
        console.log(`[sync-docs] Updated ${label}`);
    }
    return true;
};

const isCheck = process.argv.includes('--check');
let ok = true;

const manifest = JSON.parse(fs.readFileSync(MANIFEST_PATH, 'utf8'));
const ordered = [
    ...(Array.isArray(manifest.priority) ? manifest.priority : []),
    manifest.entry || 'core/orchestrators/CoreOrchestrator.js'
];

const docBuffer = fs.readFileSync(DOC_PATH);
const docText = docBuffer.toString('utf8');
const newline = detectNewline(docText);
const list = ordered
    .map((file, index) => `${index + 1}. \`${file}\``)
    .join(newline);

const expectedBlock = `${START}${newline}${list}${newline}${END}`;
const startBuffer = Buffer.from(START, 'ascii');
const endBuffer = Buffer.from(END, 'ascii');
const startIndex = docBuffer.indexOf(startBuffer);
const endIndex = docBuffer.indexOf(endBuffer);

if (startIndex === -1 || endIndex === -1 || endIndex < startIndex) {
    console.error('[sync-docs] Load order markers not found in docs/ARCHITECTURE.md');
    process.exit(1);
}

const updatedBuffer = Buffer.concat([
    docBuffer.slice(0, startIndex),
    Buffer.from(expectedBlock, 'ascii'),
    docBuffer.slice(endIndex + endBuffer.length)
]);

if (isCheck) {
    if (!docBuffer.equals(updatedBuffer)) {
        console.error('[sync-docs] docs/ARCHITECTURE.md is out of sync with build/manifest.json');
        ok = false;
    }
} else if (!docBuffer.equals(updatedBuffer)) {
    fs.writeFileSync(DOC_PATH, updatedBuffer);
    console.log('[sync-docs] Updated docs/ARCHITECTURE.md module load order');
}

try {
    const config = loadExport(CONFIG_SRC_PATH, 'CONFIG');
    const logTags = loadExport(LOG_TAGS_SRC_PATH, 'LogTags');
    const configDoc = renderConfigDoc(config, '\n');
    const logTagsDoc = renderLogTagsDoc(logTags, '\n');
    ok = syncDoc(CONFIG_DOC_PATH, configDoc, 'docs/CONFIG.md', isCheck) && ok;
    ok = syncDoc(LOG_TAGS_DOC_PATH, logTagsDoc, 'docs/LOG_TAGS.md', isCheck) && ok;
} catch (err) {
    console.error(err.message || err);
    ok = false;
}

if (isCheck && !ok) {
    process.exit(1);
}
